package malware_gotchi;


import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

class SillyClock {
	private boolean broken = false; //if the calculator breaks, change to default (normal time)
	private long rise; //sunrise time (millisec)
	private long set; //sunset time(millisec)
	private long old_now; //normal time value (millisec)
	private long silly_now; //silly time value (millisec)
	private double maxAng = .4091; //max angle of the sun compared to lat = 0. Can vary (radians)
	private long[] solstices = {1687359480000L,1718916600000L,1750473720000L}; //list of solstices
	private long ts0; //previous solstice (millisec)
	private long ts1; //next solstice (millisec)
	private double lat; //latitude (turn to radians)
	private double lon; //longitude (turn to radians)
	
	SillyClock(long now){
		old_now = now;
		getLoc();
		getSolstices();
		calcRiseSet();
	}
	
	private void getLoc() {
		lat = 42.34254 * Math.PI / 180;
		lon = -71.10490 * Math.PI / 180; //set at res campus, TEMP
	}
	
	private void getSolstices () {
		int i = 0;
		while (solstices[i]>old_now) {
			i+=1;
			if (i+1 >= solstices.length) {
				broken=true;
				break;
			}
		}
		if (i+1 >= solstices.length) {
			broken = true;
			System.out.println("SILLY CLOCK has run out of solstices! Switching to normal time...");
		}
		else if (old_now > solstices[i+1]){
			broken = true;
			System.out.println("SILLY CLOCK has detected a time before it was made for! Switching to normal time...");
		}
		else {
			ts0 = solstices[i];
			ts1 = solstices[i+1];
		}
	}
	
	
	
	
	//IMPLEMENTATION NOTE: ADD IN TIME CHANGE STUFFS
	private void calcRise(long t, double check, double acc) {
		double laSun= Math.cos(((double)(t-ts0))/((double)(ts1-ts0))*2*Math.PI)*maxAng; //sun latitude
	    double cd = (6.24004077 + 0.01720197 * (((double)(t-946684800000L))/60/60/24/1000));
	    double off = -7.659 * Math.sin(cd)+9.863*Math.sin(2*cd+3.5932); //sun offset
	    double loSun = -(off/60/24)*2*Math.PI; //sun longitude
	    
	    double y = Math.cos(lat)*Math.cos(laSun)*(Math.cos(lon+check)*Math.cos(loSun)+Math.sin(lon+check)*Math.sin(loSun))+Math.sin(lat)*Math.sin(laSun);
	    if (y < acc && y > -1*acc) {
	    	rise = angToT(check, t);
	    }
	    else {calcRise(t,check-y,acc);}
	}
	
	private long angToT(double ang, long t) { //change a calculated angle to potential time +-24 hrs
		long noon = 43200000L + 86400000L*(t/86400000L);
		System.out.println((long)(ang*12/Math.PI*60*60*1000)+noon);
		return (long)(ang*12/Math.PI*60*60*1000)+noon;
	}
	
	private void calcSet(long t, double check, double acc) {
		double laSun= Math.cos((((double)(t-ts0))/((double)(ts1-ts0)))*2*Math.PI)*maxAng; //sun latitude
	    double cd = (6.24004077 + 0.01720197 * (((double)(t-946684800000L))/60/60/24/1000));
	    double off = -7.659 * Math.sin(cd)+9.863*Math.sin(2*cd+3.5932); //sun offset
	    double loSun = -(off/60/24)*2*Math.PI; //sun longitude
	    
	    double y = Math.cos(lat)*Math.cos(laSun)*(Math.cos(lon+check)*Math.cos(loSun)+Math.sin(lon+check)*Math.sin(loSun))+Math.sin(lat)*Math.sin(laSun);
	    if (y < acc && y > -1*acc) {
	    	set = angToT(check, t);
	    }
	    else {calcSet(t,check+y,acc);}	
	}
	
	private void fixDays() { //fix when the sunrise and sunset are (default is faulty)
		while (rise-set > 86400000 || set-rise > 86400000) {
			if (rise > set) {rise -=86400000;}
			else {set-=86400000;}
		}
		while (rise<old_now&&set<old_now) {
			if (rise<set) {rise += 86400000;}
			else {set+=86400000;}
		}
		while (rise>old_now&&set>old_now) {
			if (rise>set) {rise -= 86400000;}
			else {set-=86400000;}
		}
	}
	
	private void calcRiseSet() { //set both sunrise and sunset to an accurate time
		calcRise(old_now, 0, 0.0001);
		calcSet(old_now, 0, 0.0001);
		fixDays();
		for (int i = 0; i > -3; i--) {
			calcRise(rise, 0, 0.0000001*(Math.pow(10,i)));
			calcSet(set, 0, 0.0000001*(Math.pow(10,i)));
			fixDays();
		}
	}
	
	private void checkUpdate() {
		if (rise < old_now && set < old_now) {
			calcRiseSet();
		}
		else if (rise > old_now && set > old_now) { //might not be necessary: not how time works
			calcRiseSet();
		}
	}
	
	private void calcTime() {
		// today    //from https://stackoverflow.com/questions/6850874/how-to-create-a-java-date-object-of-midnight-today-and-midnight-tomorrow
		Calendar date = new GregorianCalendar();
		// reset hour, minutes, seconds and millis
		date.set(Calendar.HOUR_OF_DAY, 0);
		date.set(Calendar.MINUTE, 0);
		date.set(Calendar.SECOND, 0);
		date.set(Calendar.MILLISECOND, 0);
		long tMidnight = date.getTimeInMillis();
		if (rise<set) {silly_now = ((old_now-rise)*43200000)/((set-rise)) +tMidnight+21600000;}
		else {
			if (old_now-tMidnight < 12) {silly_now = (old_now-set)/(rise-set)*43200000 +tMidnight-21600000;}
			else {silly_now = (old_now-set)/(rise-set)*43200000 +tMidnight+64800000;}			
		}
	}
	
	public long getSillyTime(long now) {
		old_now = now;
		
		if (!broken) {
			checkUpdate();
			calcTime();
			return silly_now;
		}
		else {return old_now;}
	}
	
	public String getTimeStr(long now) {
		System.out.println(rise);
		System.out.println(set);
		Date date = new Date(getSillyTime(now));
		System.out.println(getSillyTime(now));
		System.out.println(old_now);
		SimpleDateFormat formatter = new SimpleDateFormat("hh:mm:ss a 'on' M/d/YY");
		return formatter.format(date);	
		
	}
}